# Результаты Бенчмарков: RabbitMQ vs Kafka

В этом проекте я протестировал два популярных решения для обмена сообщениями: **RabbitMQ** и **Kafka**. Целью было не только сравнить их производительность, но и изучить, как каждая из систем справляется с разными нагрузками, включая подтверждение доставки сообщений в RabbitMQ. Вот что мне удалось выяснить.

---

## RabbitMQ: стабильность и надёжность

RabbitMQ продемонстрировал стабильную производительность даже в сложных конфигурациях. В тестах с **одним продюсером и одним консюмером** я получил производительность **0.765 ops/ms**, что является отличным результатом. При увеличении числа участников до **10 продюсеров и 10 консюмеров** производительность упала, но система продолжала справляться с нагрузкой благодаря своей архитектуре. Важно отметить, что RabbitMQ гарантирует, что каждое сообщение будет обработано только один раз, что делает её идеальной для задач, где важна надёжность.

Тесты с подтверждением доставки показали небольшие задержки в обмене сообщениями, но это компенсировалось стабильностью и гарантией, что каждое сообщение достигнет своей цели. Например, с подтверждением в конфигурации с одним продюсером и одним консюмером производительность составила **0.551 ops/ms**.

RabbitMQ отлично подходит для сценариев, где нужно чётко распределить работу между консюмерами, исключить потери данных и обеспечить надёжную доставку сообщений. Однако при большом объёме данных и высоком числе участников производительность может снижаться из-за централизованной архитектуры и процесса подтверждения доставки.

---

## Kafka: гибкость и масштабируемость

Kafka, в свою очередь, проявила себя как мощное решение для потоковой обработки данных. Её архитектура с партиционированием данных позволяет эффективно распределять нагрузку и масштабировать систему. В простых конфигурациях, например с одним продюсером и одним консюмером, Kafka показала стабильные результаты. Однако, при увеличении числа участников производительность снижалась, что связано с накладными расходами на синхронизацию.

Тем не менее, Kafka остаётся отличным выбором для задач, где важна высокая скорость записи и гибкий доступ к данным. В стресс-тестах система продолжала работать предсказуемо, хотя и с заметными задержками.

---

## Итоги

- **RabbitMQ** отлично справляется с задачами, где важна надёжная доставка сообщений, равномерное распределение нагрузки и устойчивость к сложным сценариям. В тестах с подтверждением сообщений я увидел, как система сохраняет стабильность даже при высоких требованиях к надёжности.

- **Kafka** продемонстрировала свою силу в задачах потоковой обработки данных. Её архитектура позволяет обрабатывать большие объёмы сообщений с высокой скоростью. Однако в сложных сценариях с большим количеством участников накладные расходы могут снижать производительность.

### Личный опыт

Я убедился, что каждая из систем имеет свои сильные стороны. RabbitMQ я бы выбрал для микросервисов, где важно распределить работу и гарантировать доставку сообщений. Kafka же прекрасно подходит для задач аналитики, мониторинга и потоковой обработки данных. В обоих случаях правильная настройка под конкретные задачи может существенно улучшить производительность.


## Kafka

Тестировались сценарии с различным количеством продюсеров и консюмеров. Вот полученные результаты:

```
Benchmark                                                              Mode  Cnt   Score    Error   Units
MultipleProducersMultipleConsumers.kafkaProducerConsumer               thrpt    5  ? 10??           ops/ms
MultipleProducersSingleConsumer.kafkaProducerConsumer                  thrpt    5   0,012 ±  0,004  ops/ms
SingleProducerMultipleConsumers.kafkaProducerConsumer                  thrpt    5  ? 10??           ops/ms
SingleProducerSingleConsumer.kafkaProducerConsumer                     thrpt    5   0,006 ±  0,001  ops/ms
StressTest.kafkaProducerConsumer                                       thrpt    5  ? 10??           ops/ms
```

---

## RabbitMQ

Тестировались стандартные сценарии и сценарии с подтверждением доставки сообщений.

```
Benchmark                                                                       Mode  Cnt   Score    Error   Units
MultipleProducersMultipleConsumers.rabbitProducerConsumer                       thrpt    5   0,228 ±  0,146  ops/ms
MultipleProducersSingleConsumer.rabbitProducerConsumer                          thrpt    5   0,716 ±  0,308  ops/ms
SingleProducerMultipleConsumers.rabbitProducerConsumer                          thrpt    5   0,242 ±  0,101  ops/ms
SingleProducerSingleConsumer.rabbitProducerConsumer                             thrpt    5   0,766 ±  0,342  ops/ms
StressTest.rabbitProducerConsumer                                               thrpt    5   0,062 ±  0,045  ops/ms

                                                                                          Mode  Cnt   Score    Error   Units
MultipleProducersMultipleConsumersWithConfirmation.rabbitProducerConsumerWithConfirmation thrpt    5   0,181 ±  0,052  ops/ms
MultipleProducersSingleConsumerWithConfirmation.rabbitProducerConsumerWithConfirmation    thrpt    5   0,325 ±  0,045  ops/ms
SingleProducerMultipleConsumersWithConfirmation.rabbitProducerConsumerWithConfirmation    thrpt    5   0,030 ±  0,003  ops/ms
SingleProducerSingleConsumerWithConfirmation.rabbitProducerConsumerWithConfirmation       thrpt    5   0,551 ±  0,182  ops/ms
StressTestWithConfirmation.rabbitProducerConsumerWithConfirmation                         thrpt    5   0,017 ±  0,001  ops/ms
```